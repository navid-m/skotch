function K(k,q){return{x:k.x+q.x,y:k.y+q.y,z:k.z+q.z}}function W(k,q){return{x:k.x-q.x,y:k.y-q.y,z:k.z-q.z}}function J(k,q){return{x:k.x*q,y:k.y*q,z:k.z*q}}function j(k){return Math.sqrt(k.x*k.x+k.y*k.y+k.z*k.z)}class z{radius;offset;constructor(k,q={x:0,y:0,z:0}){this.radius=k;this.offset=q}}class I{velocity={x:0,y:0,z:0};mass;accumulatedForce={x:0,y:0,z:0};constructor(k=1){this.mass=k}applyForce(k){this.accumulatedForce=K(this.accumulatedForce,k)}integrate(k,q){if(q<=0)return;let L=this.accumulatedForce.x/this.mass,H=this.accumulatedForce.y/this.mass,E=this.accumulatedForce.z/this.mass;this.velocity.x+=L*q,this.velocity.y+=H*q,this.velocity.z+=E*q,k.x+=this.velocity.x*q,k.y+=this.velocity.y*q,k.z+=this.velocity.z*q,this.accumulatedForce={x:0,y:0,z:0}}}function M(k,q,L){k.userData=k.userData||{},k.userData.physics={body:q,collider:L}}function P(k,q){for(let H of k){let E=H?.userData?.physics;if(!E||!E.body)continue;E.body.integrate(H.transform.position,q)}let L=0.5;for(let H=0;H<k.length;H++){let E=k[H],F=E?.userData?.physics;if(!F||!F.collider)continue;for(let U=H+1;U<k.length;U++){let R=k[U],G=R?.userData?.physics;if(!G||!G.collider)continue;let w=K(E.transform.position,F.collider.offset),C=K(R.transform.position,G.collider.offset),O=W(C,w),T=j(O),X=F.collider.radius+G.collider.radius;if(T===0)O.x=0.001,O.y=0.001,O.z=0.001;if(T<X){let N=X-T,Q=J(O,1/(T||1)),Y=J(Q,N*0.5);if(E.transform.position=K(E.transform.position,J(Y,-1)),R.transform.position=K(R.transform.position,Y),F.body&&G.body){let D=F.body.velocity,f=G.body.velocity,V=W(f,D),Z=V.x*Q.x+V.y*Q.y+V.z*Q.z;if(Z>0)continue;let _=F.body.mass>0?1/F.body.mass:0,$=G.body.mass>0?1/G.body.mass:0,g=-(1+L)*Z/(_+$),x=J(Q,g);F.body.velocity=W(F.body.velocity,J(x,_)),G.body.velocity=K(G.body.velocity,J(x,$))}}}}}var A={SphereCollider:z,SimplePhysicsBody:I,attachPhysics:M,stepPhysics:P};export{P as stepPhysics,A as default,M as attachPhysics,z as SphereCollider,I as SimplePhysicsBody};
