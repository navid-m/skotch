class h{x;y;z;constructor(t=0,e=0,r=0){this.x=t;this.y=e;this.z=r}add(t){return new h(this.x+t.x,this.y+t.y,this.z+t.z)}subtract(t){return new h(this.x-t.x,this.y-t.y,this.z-t.z)}multiply(t){return new h(this.x*t,this.y*t,this.z*t)}normalize(){let t=Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z);return t>0?new h(this.x/t,this.y/t,this.z/t):new h}cross(t){return new h(this.y*t.z-this.z*t.y,this.z*t.x-this.x*t.z,this.x*t.y-this.y*t.x)}static zero(){return new h(0,0,0)}static up(){return new h(0,1,0)}}class a{data;constructor(t){this.data=new Float32Array(t||a.identityData())}static identityData(){return[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]}static identity(){return new a}static perspective(t,e,r,n){let i=1/Math.tan(t/2),o=1/(r-n);return new a([i/e,0,0,0,0,i,0,0,0,0,(r+n)*o,-1,0,0,r*n*o*2,0])}static lookAt(t,e,r){let n=t.subtract(e).normalize(),i=r.cross(n).normalize(),o=n.cross(i).normalize();return new a([i.x,o.x,n.x,0,i.y,o.y,n.y,0,i.z,o.z,n.z,0,-i.x*t.x-i.y*t.y-i.z*t.z,-o.x*t.x-o.y*t.y-o.z*t.z,-n.x*t.x-n.y*t.y-n.z*t.z,1])}static translation(t,e,r){return new a([1,0,0,0,0,1,0,0,0,0,1,0,t,e,r,1])}static rotationX(t){let e=Math.cos(t),r=Math.sin(t);return new a([1,0,0,0,0,e,r,0,0,-r,e,0,0,0,0,1])}static rotationY(t){let e=Math.cos(t),r=Math.sin(t);return new a([e,0,-r,0,0,1,0,0,r,0,e,0,0,0,0,1])}static rotationZ(t){let e=Math.cos(t),r=Math.sin(t);return new a([e,r,0,0,-r,e,0,0,0,0,1,0,0,0,0,1])}static scaling(t,e,r){return new a([t,0,0,0,0,e,0,0,0,0,r,0,0,0,0,1])}multiply(t){let e=new Float32Array(16),r=this.data,n=t.data;for(let i=0;i<4;i++)for(let o=0;o<4;o++)if(r&&n)e[i*4+o]=r[i*4+0]*n[0+o]+r[i*4+1]*n[4+o]+r[i*4+2]*n[8+o]+r[i*4+3]*n[12+o];return new a(Array.from(e))}}class b{static cube(t=1,e=[1,0.5,0.2,1]){let r=t/2,n=[-r,-r,r,r,-r,r,r,r,r,-r,r,r,-r,-r,-r,-r,r,-r,r,r,-r,r,-r,-r,-r,r,-r,-r,r,r,r,r,r,r,r,-r,-r,-r,-r,r,-r,-r,r,-r,r,-r,-r,r,r,-r,-r,r,r,-r,r,r,r,r,-r,r,-r,-r,-r,-r,-r,r,-r,r,r,-r,r,-r],i=[0,1,2,0,2,3,4,5,6,4,6,7,8,9,10,8,10,11,12,13,14,12,14,15,16,17,18,16,18,19,20,21,22,20,22,23],o=[0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0],f=[];for(let s=0;s<24;s++)f.push(...e);return{vertices:n,indices:i,normals:o,colors:f}}static sphere(t=1,e=32,r=[0.2,0.5,1,1]){let n=[],i=[],o=[],f=[];for(let s=0;s<=e;s++){let l=s*Math.PI/e,c=Math.sin(l),u=Math.cos(l);for(let m=0;m<=e;m++){let p=m*2*Math.PI/e,M=Math.sin(p),x=Math.cos(p)*c,d=u,A=M*c;n.push(t*x,t*d,t*A),o.push(x,d,A),f.push(...r)}}for(let s=0;s<e;s++)for(let l=0;l<e;l++){let c=s*(e+1)+l,u=c+e+1;i.push(c,u,c+1),i.push(u,u+1,c+1)}return{vertices:n,indices:i,normals:o,colors:f}}static pyramid(t=1,e=[1,0.8,0.2,1]){let r=t/2,n=[-r,0,-r,r,0,-r,r,0,r,-r,0,r,0,t,0,0,t,0,0,t,0,0,t,0],i=[0,1,2,0,2,3,0,1,4,1,2,5,2,3,6,3,0,7],o=[];for(let s=0;s<n.length/3;s++)o.push(0,1,0);let f=[];for(let s=0;s<n.length/3;s++)f.push(...e);return{vertices:n,indices:i,normals:o,colors:f}}static torus(t=1,e=0.3,r=32,n=[0.8,0.2,0.8,1]){let i=[],o=[],f=[],s=[];for(let l=0;l<=r;l++){let c=l*2*Math.PI/r;for(let u=0;u<=r;u++){let m=u*2*Math.PI/r,p=(t+e*Math.cos(m))*Math.cos(c),M=e*Math.sin(m),y=(t+e*Math.cos(m))*Math.sin(c);i.push(p,M,y);let x=Math.cos(m)*Math.cos(c),d=Math.sin(m),A=Math.cos(m)*Math.sin(c);f.push(x,d,A),s.push(...n)}}for(let l=0;l<r;l++)for(let c=0;c<r;c++){let u=l*(r+1)+c,m=u+r+1;o.push(u,m,u+1),o.push(m,m+1,u+1)}return{vertices:i,indices:o,normals:f,colors:s}}}class w{position=new h(0,0,0);rotation=new h(0,0,0);scale=new h(1,1,1);getMatrix(){let t=a.translation(this.position.x,this.position.y,this.position.z),e=a.rotationX(this.rotation.x),r=a.rotationY(this.rotation.y),n=a.rotationZ(this.rotation.z),i=a.scaling(this.scale.x,this.scale.y,this.scale.z);return t.multiply(r).multiply(e).multiply(n).multiply(i)}}class g{geometry;transform=new w;userData={};buffers;constructor(t){this.geometry=t}initBuffers(t){let e=t.createBuffer();t.bindBuffer(t.ARRAY_BUFFER,e),t.bufferData(t.ARRAY_BUFFER,new Float32Array(this.geometry.vertices),t.STATIC_DRAW);let r=t.createBuffer();t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,r),t.bufferData(t.ELEMENT_ARRAY_BUFFER,new Uint16Array(this.geometry.indices),t.STATIC_DRAW);let n=t.createBuffer();t.bindBuffer(t.ARRAY_BUFFER,n),t.bufferData(t.ARRAY_BUFFER,new Float32Array(this.geometry.normals),t.STATIC_DRAW);let i=t.createBuffer();t.bindBuffer(t.ARRAY_BUFFER,i),t.bufferData(t.ARRAY_BUFFER,new Float32Array(this.geometry.colors),t.STATIC_DRAW),this.buffers={vertex:e,index:r,normal:n,color:i}}getBuffers(){return this.buffers}}class v{position=new h(0,0,5);target=new h(0,0,0);up=h.up();fov=Math.PI/4;aspect=1;near=0.1;far=100;getViewMatrix(){return a.lookAt(this.position,this.target,this.up)}getProjectionMatrix(){return a.perspective(this.fov,this.aspect,this.near,this.far)}}class L{gl;program;locations;constructor(t){let e=t.getContext("webgl");if(!e)throw Error("WebGL not supported");this.gl=e,this.initShaders(),this.setupGL()}initShaders(){let r=this.compileShader(`
      attribute vec3 aPosition;
      attribute vec3 aNormal;
      attribute vec4 aColor;

      uniform mat4 uModelMatrix;
      uniform mat4 uViewMatrix;
      uniform mat4 uProjectionMatrix;
      uniform vec3 uLightDirection;

      varying vec4 vColor;
      varying float vLighting;

      void main() {
        gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(aPosition, 1.0);
        
        vec3 normal = normalize((uModelMatrix * vec4(aNormal, 0.0)).xyz);
        float lighting = max(dot(normal, normalize(uLightDirection)), 0.3);
        
        vColor = aColor;
        vLighting = lighting;
      }
    `,this.gl.VERTEX_SHADER),n=this.compileShader(`
      precision mediump float;
      
      varying vec4 vColor;
      varying float vLighting;

      void main() {
        gl_FragColor = vec4(vColor.rgb * vLighting, vColor.a);
      }
    `,this.gl.FRAGMENT_SHADER),i=this.gl.createProgram();if(this.gl.attachShader(i,r),this.gl.attachShader(i,n),this.gl.linkProgram(i),!this.gl.getProgramParameter(i,this.gl.LINK_STATUS))throw Error("Program linking failed: "+this.gl.getProgramInfoLog(i));this.program=i,this.gl.useProgram(i),this.locations={position:this.gl.getAttribLocation(i,"aPosition"),normal:this.gl.getAttribLocation(i,"aNormal"),color:this.gl.getAttribLocation(i,"aColor"),modelMatrix:this.gl.getUniformLocation(i,"uModelMatrix"),viewMatrix:this.gl.getUniformLocation(i,"uViewMatrix"),projectionMatrix:this.gl.getUniformLocation(i,"uProjectionMatrix"),lightDirection:this.gl.getUniformLocation(i,"uLightDirection")}}compileShader(t,e){let r=this.gl.createShader(e);if(this.gl.shaderSource(r,t),this.gl.compileShader(r),!this.gl.getShaderParameter(r,this.gl.COMPILE_STATUS))throw Error("Shader compilation failed: "+this.gl.getShaderInfoLog(r));return r}setupGL(){this.gl.enable(this.gl.DEPTH_TEST),this.gl.enable(this.gl.CULL_FACE),this.gl.clearColor(0.1,0.1,0.15,1)}clear(){this.gl.clear(this.gl.COLOR_BUFFER_BIT|this.gl.DEPTH_BUFFER_BIT)}render(t,e){if(!this.program||!this.locations)return;if(!t.getBuffers())t.initBuffers(this.gl);let n=t.getBuffers();this.gl.uniformMatrix4fv(this.locations.modelMatrix,!1,t.transform.getMatrix().data),this.gl.uniformMatrix4fv(this.locations.viewMatrix,!1,e.getViewMatrix().data),this.gl.uniformMatrix4fv(this.locations.projectionMatrix,!1,e.getProjectionMatrix().data),this.gl.uniform3f(this.locations.lightDirection,0.5,0.7,1),this.gl.bindBuffer(this.gl.ARRAY_BUFFER,n.vertex),this.gl.enableVertexAttribArray(this.locations.position),this.gl.vertexAttribPointer(this.locations.position,3,this.gl.FLOAT,!1,0,0),this.gl.bindBuffer(this.gl.ARRAY_BUFFER,n.normal),this.gl.enableVertexAttribArray(this.locations.normal),this.gl.vertexAttribPointer(this.locations.normal,3,this.gl.FLOAT,!1,0,0),this.gl.bindBuffer(this.gl.ARRAY_BUFFER,n.color),this.gl.enableVertexAttribArray(this.locations.color),this.gl.vertexAttribPointer(this.locations.color,4,this.gl.FLOAT,!1,0,0),this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER,n.index),this.gl.drawElements(this.gl.TRIANGLES,t.geometry.indices.length,this.gl.UNSIGNED_SHORT,0)}}class R{renderer;camera;meshes=[];animationCallbacks=[];isAnimating=!1;lastTime=0;constructor(t){this.renderer=new L(t),this.camera=new v,this.camera.aspect=t.width/t.height}add(t){return this.meshes.push(t),t}remove(t){let e=this.meshes.indexOf(t);if(e>-1)this.meshes.splice(e,1)}setCamera(t){this.camera=t}getCamera(){return this.camera}onAnimate(t){this.animationCallbacks.push(t)}render(){this.renderer.clear();for(let t of this.meshes)this.renderer.render(t,this.camera)}startAnimation(){if(this.isAnimating)return;this.isAnimating=!0,this.lastTime=performance.now(),this.animate()}stopAnimation(){this.isAnimating=!1}animate=()=>{if(!this.isAnimating)return;let t=performance.now(),e=(t-this.lastTime)/1000;this.lastTime=t;for(let r of this.animationCallbacks)r(e);this.render(),requestAnimationFrame(this.animate)}}class E{static createScene(t){let e=document.getElementById(t);if(!e)throw Error(`Canvas with id "${t}" not found`);return new R(e)}static createCube(t,e){return new g(b.cube(t,e))}static createSphere(t,e,r){return new g(b.sphere(t,e,r))}static createPyramid(t,e){return new g(b.pyramid(t,e))}static createTorus(t,e,r,n){return new g(b.torus(t,e,r,n))}static Vec3=h;static Camera=v}var F=E;export{F as default,h as Vec3,w as Transform,E as Skotch,R as Scene,L as Renderer,g as Mesh,a as Mat4,b as GeometryBuilder,v as Camera};
